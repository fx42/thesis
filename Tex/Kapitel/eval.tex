\chapter{Zusammenfassung und Ausblick}\label{eval}
Ziel dieser Arbeit war es einen Einblick in das Thema Reactive Programming zu ermöglichen. Dazu wurde geklärt wie reaktives Verhalten mit schon bekannten Prinzipien der Softwareentwicklung realisiert werden kann. Ebenso hat eine Differenzierung zwischen Reactive Programming und Reactive Systems stattgefunden. Anschließend wurden die notwendigen Bestandteile, das Observer Pattern sowie Back Pressure, der Reactive Streams geschildert. Eine mögliche Art der Implementierung dieser Prinzipien wurden mit der Beschreibung der Referenzbibliothek RxJava genauer betrachtet. Die notwendigen Bestandteile und Basisklassen, wie Observable oder Scheduler, wurden für ein besseres Verständnis im Detail beschrieben. Mit Code-Beispielen wurde eine mögliche Implementierung der Klassen und deren Zusammenhänge veranschaulicht. Am Beispiel eines einfachen Systemmonitors wurden einige der zuvor beschriebenen Konzepte angewandt. Gerade die Weitergabe von Observables und die Weiterverwendung dieser stand hier im Mittelpunkt. Im Zusammenspiel mit JavaFX wurde somit eine reaktive Anwendung mit Benutzeroberfläche implementiert. \\ \\ Hier liegt auch schon einer der großen Vorteile von Reactive Programming. Im Bereich der Entwicklung von GUIs liegt klar eine Stärke dieses Programmierparadigmas. Asynchrone Events, wie Verarbeiten einer Eingabe oder Datenbeschaffung von einer Datenbank oder einer Festplatte, blockieren die Anwendung nicht, und nach Abschließen des Events werden die notwendigen weiteren Schritte gestartet. Durch das nicht Blockieren bekommt der Benutzer ständig Feedback auf seine Interaktion was sich positiv auf die User Experience auswirkt. Ein weiterer Aspekt ist die asynchrone Kommunikation über ein Netzwerk. Viele Applikationen kommunizieren über das Internet, zum Beispiel über REST-Schnittstellen. Diese Anfragen können in Punkten wie Latenz und Bearbeitungszeit auf Serverseite variieren. Auch hier bringt Reactive Programming wieder den Vorteil, dass nach stellen der Anfrage die Applikation nicht blockiert, sondern weiter verwendet werden kann, und sobald eine Antwort eingegangen ist, stößt diese die weitere Verarbeitung an. Die beiden Anwendungsbeispiele beziehen sich auf den Kern des Reactive Programming, die Asynchronität. Besteht eine Abhängigkeit zwischen asynchron angestoßenen Events steigt die Komplexität der imperativen Programmierung und die Verwendung von reaktiver Programmierung ist klar zu bevorzugen. Sind Events jedoch vollkommen unabhängig und eine asychrone Behandlung stellt keine Anforderung dar, ist der imperative Weg oft schneller, da der Overhead den die Implementierung eines reaktiven Frameworks mitbringt umgangen werden kann. Alles in allem ist zu sagen, dass es sich bei Reactive Programming um ein Werkzeug handelt das, wenn es zu den richtigen Aufgaben verwendet wird, eine große Stärke in der Verarbeitung von asynchronen Ereignissen an den Tag legt. Jedoch ist es kein Werkzeug für jede Art von Arbeit, es muss also schon bei der Konzeption einer Anwendung analysiert werden, ob solch ein Verhalten als Anforderung besteht, und die Entscheidung für oder gegen Reactive Programming muss getroffen werden. Auch kann diese Überlegung bei schon bestehenden Anwendungen durchgeführt werden, da gerade wegen der Dualität des Observables zum Iterator eine Umstellung auch zyklisch stattfinden kann. Zu dieser Überlegung kommt noch hinzu, ob APIs verwendet werden, die über ein reaktives Verhalten verfügen. Dies bezieht sich wieder eher auf Reactive Systems, wie jedoch schon erwähnt, ist die Verwendung von Reactive Programming zur Realisierung von komplett reaktiven Systemen meist sinnvoll. Im aktuellen Aufschwung der Microservice-Architektur ist ein vermehrtes Aufkommen von reaktiv implementierten Services in Zukunft naheliegend. Diese Architektur kann als verteiltes System verstanden werden, es herrscht rege Kommunikation zwischen den Services oder Fremddiensten und eine asynchrone Bearbeitung von Anfragen kann den Ablauf stark zum positiven beeinflussen. Ebenso wird es im mobilen Bereich wie der Android-Entwicklung vermehrt auftreten, da hier fast alle Applikationen auf häufige Benutzerinteraktion ausgelegt sind. Hierfür gibt es schon eine spezielle Erweiterung der RxJava-Bibliothek um die bestmöglichen Resultate auf Android-Geräten zu erzielen \cite{android}. Gerade hier könnte sich Reactive Programming als eine \textit{Best Practice} Methode profilieren.

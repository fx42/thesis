\chapter{Einführung in Reactive Programming mit RxJava2}\label{rp_einfuehrung}
Der zentrale Baustein dieser Bibliothek ist das Observable Interface im Zusammenspiel mit dem Observer Interface. Ein Observable repräsentiert einen Data- beziehungsweise Eventstream. Es ist für das push-Verfahren konzipiert (reaktiv) kann aber auch mit dem pull-Vorgehen verwendet werden (interaktiv)\footnote{Vgl. \cite{Nurkiewicz.2017}, Seite 4.}. Weitere Eigenschaften sind die Nutzung für asynchrone und synchrone Implementierungen und die Repräsentation von Null bis unendliche\footnote{Mathematisch gesehen: $D = [0, \infty)$} viele Werte oder Ereignisse im Laufe der Zeit. Es folgt nun eine kurze Schilderung wie diese Eigenschaften erreicht werden bevor die eigentlichen Struktur der Bibliothek veranschaulicht wird. Diese Eigenschaften wurden vom bereits erwähnten Ben Christensen in Kapitel 1 innerhalb des Buches von Tomasz Nurkiewicz \footnote{\cite{Nurkiewicz.2017}} beschrieben.
\section{Synchronität und Asynchronität}
Bei dem bisher gelesenen wird schnell klar, dass die Asynchronität ein essentieller Bestandteil sein muss. Jedoch ist das Observable standardmäßig synchron implementiert und ein asynchrones Verhalten muss explizit gefordert werden. Erfolg eine Subscription eines Observers an einem Observable wird die Weitergabe der Elemente des Streams auf dem Thread des Observers ausgeführt. Ebenso finden die Bulk Operations, also Transformation, Modifikation und Komposition der Elemente oder Streams grundsätzlich synchron statt. Werden also Daten zum Beispiel aus einem Cache geladen und über den Stream zur Verfügung gestellt ist der Standardweg des synchronen Vorgehens vollkommen richtig um den Overhead der expliziten Asynchronität zu umgehen. Finden aber Abfragen zum Beispiel über eine Netzwerkressource statt, die unterschiedliche lange Latenzen aufweist, kann es notwendig sein die Anfragen auf weiteren Threads auszuführen. Dies kann mittels eigens erstellte Threads, Threadpools oder Schedulers umgesetzt werden. Somit werden die Callback Methoden des Observers von dem zusätzlichen erstellten Thread aufgerufen und der eigentliche Observer Thread wird nicht weiter blockiert.
\section{Parallelisierung und Nebenläufigkeit}
Wie bekannt sein dürfte ist die Parallelisierung und Nebenläufigkeit eher auf Systemebene zu betrachten. Als parallel bezeichnet man die Ausführung unterschiedlicher Tasks auf verschiedenen Kernen oder Maschinen. Voraussetzung ist die wirklich gleichzeitige Bearbeitung der Tasks. Von Nebenläufigkeit wird gesprochen wenn eine Recheneinheit mehre Tasks oder Threads verarbeitet und immer nur einer dieser Aufgaben zur einer Zeit bearbeitet wird. Nach einem gewissen Zeitraum bekommt ein anderen Task die Rechenleistung und die vorherige Task wurde beendet wenn die Aufgabe erfüllt wurde oder wartet auf erneute Rechenzeit. Dieses Verfahren wird \textit{time slicing} genannt und wird von Kernel des Betriebssystems verwaltet. Somit ist Parallelisierung immer auch nebenläufig aber Nebenläufigkeit nicht unbedingt auch parallelisiert. Um dieses Verfahren in Verbindung mit den Observables zu bringen ist zu sagen, dass ein Observable Objekt immer serialisiert und thread-safe sein muss. Die Callback-Methoden des Subscribers dürfen also nie zeitgleich aufgerufen werden. Parallelisierung und Nebenläufigkeit werden also dadurch erreicht, dass man Observables miteinander verbindet und jeder der Streams parallel oder nebenläufig mit den jeweils anderen interagieren kann zum Beispiel mit den Bulk-Operations merge und zip, aber dazu später mehr.
\section{Push und Pull}
Wird synchrones Pulling von Objekten einer Liste über das Iterable Interface durchgeführt, so wird im Gegenzug ein asynchrones Pushing via Observable realisiert. Beide Schnittstellen bieten die gleiche Funktionalität nur der Datenfluss findet in die entgegengesetzte Richtung statt. Durch diese Dualität können beide Vorgehen äquivalent verwendet werden. Will man ein weiteres Objekt einer Liste über den Iterator abfragen, wird die next()-Methode aktiv aufgerufen und wenn vorhanden wird ein weiteres Objekt dem Verbraucher zurück gegeben. Hingegen wird bei der Verwendung von Observables die Daten des Streams mit der onNext()-Methode\footnote{Diese Methode wird durch ein Autftreten eines Ereignisses oder von Daten im Stream aufgerufen. Somit handelt es sich bei dieser Art Methode um Callback Methoden.} des Verbrauchers gepusht. Wie die Tabelle \ref{tbl.vglIterObs}\footnote{Quelle: \cite{reactivex.io}} zeigt gilt dies ebenso beim Auftreten eines Fehlers oder beim Erreichen des Endes der Datenquelle.
\begin{table}[]
	\centering
	\begin{tabular}{|c|c|lll}
		\cline{1-2}
		\cellcolor[HTML]{C0C0C0}Pull (Iterable) & \cellcolor[HTML]{C0C0C0}Push (Observable) &  &  &  \\ \cline{1-2}
		T next()                                & onNext(T)                                 &  &  &  \\ \cline{1-2}
		throws Exception                        & onError(Throwable)                        &  &  &  \\ \cline{1-2}
		returns                                 & onCompleted()                             &  &  &  \\ \cline{1-2}
	\end{tabular}
	\caption{Vergleich zwischen Funktionalität der Iterable- und Observable-Schnittstelle}
	\label{tbl.vglIterObs}
\end{table}
Die Verbindung zwischen Observable und Observer findet über ein Subscription statt. Damit werden die beiden zu einem Paar gebunden und die entsprechenden Methoden des Observers können nun von dem Stream angesprochen werden. Dies beschreibt auch noch eine weitere Eigenschaft. Ein Observable publiziert nur die Ereignisse wenn es jemanden gibt der diese Ereignisse auch fordert. Dies wird auch als \textit{faules} Verhalten bezeichnet. Somit wird das Arbeiten durch das Subscriben und nicht durch das Erstellen eines Observables verursacht. Im Vergleich dazu kann ein Objekt vom Typ Future betrachtet werden. Wird ein Future erstellt, wird auf ein Ergebnis gewartet, welches direkt und einmalig asynchron ausgeführt wird und innerhalb des Futures zur Verfügung steht sobald das Ereignis abgeschlossen ist. Ein mehrfaches Ausführen eines Futures ist nicht möglich, anders als beim Observable wo zu jeder Zeit ein weiterer Subscriber hinzu kommen kann. Somit ist ein Observable-Objekt beliebig oft verwendbar. 
\section{Rx.Observable}
Interface Übersicht. Nutzen und Anwendung anhand von Beispiel. Hot vs. Cold
\section{Rx.Observer}
Was kann Observer -> Interface Übersicht
\subsection{Rx.Subscriber}
Was ist speziell am Subscriber -> Interface Übersicht
\section{Flowable}
\section{Schedulers}
\section{Operationen}
Erläuterung von den Stadien der Operation von Beginn über Mitte bis Ende.
\subsection{Operation filter()}
Beispiel und Perlenbild. Einsatz beschreiben
\subsection{Transformation map()}
Beispiel und Perlenbild. Einsatz beschreiben
\subsection{Transformation flatMap()}
Beispiel und Perlenbild. Einsatz beschreiben
\subsection{Operation merge()}
Beispiel und Perlenbild. Einsatz beschreiben
\subsection{Operation zip()}
Beispiel und Perlenbild. Einsatz beschreiben
Eventuell noch mehr Operationen


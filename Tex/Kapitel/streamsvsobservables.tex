\chapter{Abgrenzung zwischen Java 8 Streams und Reactive Streams}\label{streams}
Im Verlauf dieser Arbeit wird beschrieben welche Bestandteile benötigt werden damit von Reactive Streams gesprochen werden kann. Bevor jedoch diese Bestandteile beschrieben werden, muss eine Abgrenzung zu den seit Java 8 vorhanden Streams stattfinden. Durch die ähnliche Art der Verwendung beider ist eine Verwechslung nicht ausgeschlossen, obwohl unterschiedliche Konzepte realisiert werden. Daher folgt eine kurze Beschreibung der Java 8 Streams und eine allgemeine Unterscheidung zu den im weiteren Lauf verwendeten Reactive Streams.
\section{Java 8 Streams}
Das Konzept der Streams stellt eine Abstraktion für Folgen von Bearbeitungsschritten auf Daten dar \cite{Inden.2015}. Streams erinnern an Collections sind jedoch nur einmal traversierbar und nehmen keine direkten Speicherung der Daten vor. Collections können auch als Streams respräsentiert werden. Nahe liegt die verbreitete Analogie der Fließbandverarbeitung. Man hat eine Menge von Objekten die nacheinander gewissen Operationen unterzogen werden. Diese wird einmalig durchgeführt und die Zwischenergebnisse bleiben nicht vorhanden. In Listing \ref{lst:streamsandbulk} sieht man, dass mit dem Methodenaufruf \textit{stream()} auf der Collection ein Stream parametrisiert auf den selben Datentyp wie die Collection erstellt werden kann. Es findet keine Änderung an den einzelnen Elemente statt, denn es wird nur das Ergebnis der Operation ausgegeben.
\lstinputlisting[linerange={7-14}, caption={Beispiel Erstellung, Verarbeitung und Ergebnisermittlung von Streams.}, label=lst:streamsandbulk]{../SystemMonitor/examples/streamsandbulk/StreamsAndBulk.java}
\subsection{Bulk Operations}
Bulk Operations gelten als funktional in sind seit Java 8 auf Collections sowie Streams anwendbar. Diese Operation müssen nicht separat implementiert werden und können direkt auf Collections oder Streams ausgeführt werden. Jedoch sind nicht zu beiden Arten die exakt gleichen Operation verfügbar. Somit kann durch eine Operation zum Beispiel eine Veränderung an jedem Objekt einer Liste ausgeführt werden, oder eben auf jedem Objekt welches einen Stream durchquert. Die Operation können verkettet werden. Als Ergebnis werden die Elemente zum Beispiel nach der Filterung ausgegeben, oder in einer neuen Liste gespeichert. Auch bei einer Verkettung wird immer nur das Ergebnis weiter gereicht, die Eingangswerte bleiben unverändert. Erwähnung sollte noch die unterschiedliche Art von Operation finden. Es wird zwischen drei Arten von Operationen unterschieden: \textit{Erzeugung}, \textit{Berechnung} und \textit{Ergebnisermittlung} die sich wie folgt abbilden lassen \cite{Inden.2015} : 
\begin{displaymath}
\underbrace{Quelle \Rightarrow STREAM}_{Erstellung} \Rightarrow \underbrace{OP_{1} \Rightarrow OP_{2} \Rightarrow ... \Rightarrow OP_{n}}_{Berechnung} \Rightarrow \underbrace{Ergebnis}_{Ergebnisermittlung}
\end{displaymath}
Bei der Erzeugung wird von der Änderung der Datenrepräsentation von einem Datentyp einer Collection oder eines Arrays in einen Stream gesprochen. Java bietet hierfür für jeweils Arrays oder Collections Methoden an. Resultieren erhält man einen Stream. Eine Reihe von Berechnungen kann nun verketten stattfinden, zum Beispiel eine Transformation oder Filterung nach Kriterien. Sind die Operationen abgeschlossen wird das Ergebnis zum Beispiel auf der Konsole ausgegeben oder in einem Datentyp gespeichert. Konkret ist der Ablauf in Listing \ref{lst:streamsandbulk} zu sehen. Wie vorhin schon erwähnt wird via Methodenaufruf eine Stream-Repräsentation der Collection geschaffen. Die Berechnung beziehungsweise Bearbeitung finden in der Konkatenation der Operation \textit{map()} und \textit{filter()} statt. Zuerst wird jeder String in Großbuchstaben transformiert, und das Ergebnis an die Filter-Operation weitergegeben. Anschließend wird gefiltert ob der String ein den angegeben Kriterien genügt. Die Ergebnisermittlung findet in der \textit{forEach()}-Methode statt, da hier jedes Element das nach dem filtern noch übrig ist auf die Konsole geschrieben wird. Es können noch beliebig viele Stream-Objekte von einer Collection erstellt werden, jedoch ist die Traversierung, und somit die Verwendung, eines Streams nur einmalig möglich.
\section{Unterscheidung zu Reactive Streams}
Die vorab beschriebenen Streams und ihre Operation funktionieren durch die Verwendung des Pull-Verfahrens. Mittels Iterator wird immer ein weiteres Element von der Datenquelle geholt und darauf die Operationen ausgeführt. Ebenso sind die Streams endlich, da nach der oder den Operationen der Stream terminiert. Auch sind diese Streams nur einmalig verwendbar. Wird von Reactive Streams gesprochen gelten diese Eigenschaften nicht. Es wird nach dem Push-basierten Verfahren gehandelt, was heißt, das nicht mit dem Iterator gearbeitet wird. Auch müssen diese Streams nicht endlich sein, was wiederum heißt, dass die Anzahl der Elemente nicht vorab bekannt sein muss. Auch ist eine mehrfache Verwendung dieser Reactive Streams möglich. Die Bulk Operations sind auch auf Reactive Streams möglich, es liegen jedoch viele weitere Operationen vor die speziell für die Verwendung des reaktiven Verhalten implementiert wurden. Diese signifikanten Unterschiede zeigen, dass wenn auch in beiden Fällen von Datenströmen gesprochen wird, der grundlegende Gedanke wie mit Streams umgegangen wird eine vollkommen andere ist.
\chapter{Was ist Reactive Programming}\label{was_ist_reactive_programming}
Ist man neu in der Domäne von reaktiver Entwicklung stellt man schnell fest, dass allerhand mögliche Definitionen und Beschreibungen findet was Reactive Programming denn zu sein scheint. Bevor jedoch hier eine Definition erläutert wird, muss zwischen unterschiedlichen Begrifflichkeiten differenziert werden: \textit{Reactive Systems, Functional Reactive Programming} und natürlich \textit{Reactive Programming}. Vorab wird jedoch ergründet worum es sich grundlegend handelt und wieso es zur heutigen Zeit von Relevanz ist über die möglichen Verwendung von \textit{reactive} zu sprechen.
\section{Was bedeutet \textit{"reactive"} im Kontext der Softwareentwicklung}
Wie die Wortherkunft verlauten lässt, wird etwas als reaktiv bezeichnet, wenn eine Reaktion durch eine vorangegangene Aktion ausgelöst wird. Bei diesen Aktionen handelt es sich meist um Veränderungen an verwendeten Daten und stattfindende Ereignisse(\textit{Events}). Eine gutes Beispiel zur Veranschaulichung ist die Benutzeroberfläche(\textit{GUI}). Ein Benutzer bestätigt eine vorgenommene Eingabe durch das klicken eines Button innerhalb der GUI. Dieses Event sorgt dafür, dass die Applikation einen vorgegebenen Vorgang ausführt. Dieses Vorgehen sorgt in der klassischen objektorientierten Programmierweise mit sequentiellem Ablauf sowie dem imperativen Ansatz grundsätzlich für ein stetig wachsendes Maß an Komplexität. Durch die unterschiedlichen Events die innerhalb der GUI ausgelöst werden können(Mausklick, Tastendruck, usw.) ist ein klassischer imperativer sowie sequentieller Ablauf den Programmcodes nicht realistisch, da kein Entwickler weiß, in welcher Reihenfolge und zu welchem Zeitpunkt ein beziehungsweise welches Event ausgelöst wird. Somit spielt hier die \textit{Inversion of Control}\footnote{Vgl. \cite{MartinFowler.2005}, https://martinfowler.com/bliki/InversionOfControl.html.}, also das Umkehren der Kontrolle, eine große Rolle. Diese besagt, dass nicht der geschrieben Code den Ablauf beschreibt, sondern die Kontrolle bei dem Framework\footnote{In diesem Fall ein Framework für das Realisieren einer GUI. Vgl. \cite{wiki.guilist}.}, welches für die Interaktion zuständig ist, liegt, und dieses entscheidet wiederum wie und wann auf ein Event reagiert wird. Im Code spiegelt sich das dadurch wider, das mögliche Reaktionen, meist als Methoden oder Funktionen realisiert, an die mögliche eintreffenden Ereignisse gebunden werden. Dies geschieht über so genannte Event-Handler beziehungsweise Event-Listener oder über die Verwendung von Callbacks\footnote{TODO Beispiel Event-Handler -> ActionEvent, Click on Button; Quellen angeben und Beschreibung zu Beiden Codebeispielen}. Ein bewährtes und klassisches Vorgehen bei Anwendungsanforderungen dieser Art ist das schon 1994 von Erich Gamma und seinen Mitstreitern beschriebenes Entwurfsmuster\footnote{\cite{Gamma.2011}: Dieses Buch beschreibt viele noch heute verwendete Entwurfsmuster. Die Autoren sind in die Geschichte als die Gang Of Four (\textit{GoF}) eingegangen.}, dem \textit{Observer-Pattern}\footnote{Hier Beispiel vom OP sowie Übersetzung Beobachtermuster; Observer Pattern und Erklärung}. Man betrachtet hier grundlegend zwei Ansätze: \textit{push}  und \textit{pull}. \footnote{Hier gute Beispiele für push und pull Variante}. Auch hier lässt sich wieder die GUI als guten Beispiel heran ziehen. Man betrachtet eine Oberfläche welche die Temperatur im Raum anzeigt. Die Temperatur wird als Zahl in Grad Celsius sowie graphisch in einem Balken dargestellt. Obwohl beide Elemente auf die selben Daten zugreifen, stehen programmatisch die Objekte in keine Zusammenhang. Um nun das Beobachtermuster zu implementieren, muss der sich ändernde Wert der zum Beispiel von einem Temperatursensor gemessen wird regelmäßig aktualisiert beobachtet werden. Das Objekt, welches den Temperaturwert inne hält wird somit als beobachtbar deklariert, die beiden Objekte, die Ausgabe per Zahlenwert und der graphische Balken, werden bei diesem Objekt als Beobachter registriert. Wenn man den push-Ansatz verfolgt, wird jedem Beobachter benachrichtigt und das Objekt mit den geänderten Daten steht dem Beobachter zur Verfügung. Verfolgt man den pull-Ansatz, werden die Beobachter nur kurz darüber informiert, dass sich Werte innerhalb des zu beobachtenden Objekts geändert haben, müssen jedoch aktiv anfragen um die geänderten Werte zu erhalten. Je nach Vorgehen ergeben sich Vor- und Nachteile. Der push-Ansatz steht eher für lose Kopplung, da der Beobachter keine Details zu dem zu beobachteten Objekt braucht. Jedoch sinkt dadurch die Flexibilität, da Beobachterschnittstellen exakter beschrieben werden müssen damit der Beobachtete weiß welche Information weiter gereicht werden sollen. Die Kopplung im Vergleich zum pull-Ansatz ist nicht wirklich lose, da jeder Beobachter wissen muss, welche Daten das observierte Objekt repräsentiert und wie auf diese Daten zugegriffen werden kann. Jedoch findet sich hier die Flexibilität wieder, da jeder Beobachter wenn er Information braucht, exakt diese Daten abrufen kann und sich nicht auf die korrekte Datenverteilung des Beobachteten verlassen muss. \\ Nach diesem Abschnitt sollte soweit klar sein, wie man ein reaktives Verhalten mit den schon bekannten Bordmitteln realisiert.
\subsection{Differenzierung zwischen Reactive Proramming und Reactive Systems}
Das zuvor angesprochene Verhalten bezieht sich nur auf ein Beispiel. Wie jedoch wirkt es sich aus, wenn eine komplette Anwendung unter Verwendung dieses Stils entwickelt wird? Wie verhält es sich weiter wenn mehrere Teile reaktiv funktionieren und kommunizieren sollen? Der grundlegende Gedanke reaktiver Systeme wurde schon im Jahre 1985 in einem Paper von D. Harel und A. Pnueli beschrieben\footnote{\cite{Harel1985}}. Zur heutigen Zeit jedoch bezieht man sich bei Richtlinien zur Gestaltung reaktiver Anwendungen eher auf das Reactive Manifesto\footnote{\cite{Boner.} -> ebenso Bild von Manifest einfügen. Deutsches Manifest in Quellen verlinken}. Laut Jonas Bonér und den vielen Unterstützern sind vier Bestandteile essentiell, damit eine Anwendung die Anforderung erfüllt um sich reaktiv zu verhalten. Die Ansicht des Manifest stützt sich auf einen Architektur- beziehungsweise Designstil und soll als Grundlage zur Entwicklung Reaktiver Systeme dienen. Die folgenden Erklärungen sind dem Manifest entnommen und sollen einen Verständnis zu den vier Eigenschaften bieten. Wie in diesem beschrieben sind Reaktive Systeme:
\begin{itemize}
	\item \textbf{Antwortbereit (engl. responsive):}\\ Ein System muss immer zeitgerecht antworten. Die Antwortbereitschaft ist die Grundlage für die Benutzbarkeit besagten Systems. Ebenso wird um eine Fehlerbehandlung durchführen zu können eine geregelte Antwortbereitschaft vorausgesetzt.
	\item \textbf{Widerstandsfähig (engl. resilient):}\\ Ein System muss auch bei Ausfällen die Antwortbereitschaft aufrecht erhalten. Die wird durch Replikation der Funktionalität, der Isolation von Komponenten sowie dem Delegieren von Verantwortung erzielt. 
	\item \textbf{Elastisch (engl. elastic):}\\ Das System muss bei sich ändernden Lasten die Funktionalität und Antwortbereitschaft aufrecht erhalten. Ressourcen müssen den auftretenden Lasten, ob steigend oder sinken, angepasst werden können.Ebenso müssen Engpässe innerhalb des Systems unterbunden werden um die Elastizität zu bewahren.
	\item \textbf{Nachrichtenorientiert (engl. message driven):}\\ Ein loses System soll zur Kommunikation zwischen den Komponenten auf asynchrone, ortsunabhängige Nachrichtenübermittlung zurück greifen. Somit ist nicht relevant auf welchen Rechner die einzelnen Komponenten ausgeführt werden, wodurch wiederum eine gute Skalierbarkeit entsteht.
\end{itemize}
Das Manifest erwähnt jedoch in keinster Weise den Zusammenhang von Systemen zum reaktiven Programmieren. Auch aus diesem Grund hat Jonas Bonér einen weiteren Artikel\footnote{\cite{Boner.2014}} verfasst, der sich dieser Thematik annimmt. Die grundlegenden Unterschiede wurde in dem Artikel wie folgt zusammengefasst.
\begin{itemize}
	\item Reactive Programming ist eine Teilmenge von Reaktiven Systemen auf Implementierungsebene
	\item Reactive Programming liefert Leistung und effektive Ressourcennutzung auf Komponentenebene, speziell für Softwareentwickler
	\item Reaktive Systeme hingegen bieten Robustheit und Elastizität auf Systemebene zur Gestaltung von Cloud-kompatiblen oder verteilten Anwendungen, speziell für Softwarearchitekten oder DevOps
	\item Es ist von großem Vorteil reaktives Programmieren innerhalb der Bestandteile von reaktiven Systemen zu verwenden
	\item Es is ebenso von Vorteil reaktive Systeme zur Interaktion zwischen reaktiv programmierten Komponenten zu verwenden
\end{itemize}
Wie aus diesen Punkten klar wird, liegt also der genau Unterschied zwischen reaktivem Programmieren und reaktiven System aus welcher Perspektive die Betrachtung stattfindet. Architektonisch wird von Systemen gesprochen, die innerhalb und zur Interaktion mit anderen reaktiv reagiert. Betrachtet man das Ganze aus Entwicklersicht eine Komponente, kann diese unter Zuhilfenahme von reaktivem Programmieren für ein asynchrones, paralleles Verhalten entwickelt werden. Wie Jonas Bonér schon schreibt, ist das Zusammenspiel beider sehr oft hilfreich um das gewünschte Ziel zu erreichen. Ein weiterer wichtiger Punkt ist die Unterscheidung von \textit{ereignisorientiert} zu \textit{nachrichtenorientiert}. Nachrichten werden auf Systemebene genutzt. im Gegensatz zu Ereignissen sind Nachrichten klar an einen Empfänger adressiert. Ereignisse treten auf und müssen beobachtet werden um das gewünschte Resultat zu erzielen. Nachrichten sind somit gut geeignet bekannte Empfänger in einem verteilten System, zum Beispiel über das Netzwerk, zu kontaktieren. Innerhalb der Komponente besteht die Funktion (man denke hier wieder an die Nutzeroberfläche) oft aus der Reaktion auf Ereignisse unterschiedlicher Art die direkt in der Komponente verarbeitet werden sollen. Somit herrscht hier ein Ereignis-getriebenes Verhalten. 

\section{Reactive Programming vs. Functional Reactive Programming}
Auf der Suche nach einer Definition zu Reactive Programming stößt man oft auf es Begriff Functional Reactive Programming. Teilweise werden die Begriffe sogar synonym verwendet\footnote{Vgl.: \cite{Nurkiewicz.2017}, Seite 2.}. Grundlegend betrachtet man bei den bekannten Programmierparadigmen zwischen imperativen und deklarativen Paradigmen, wobei zum Beispiel die Objektorientierte Programmierung im imperativen und funktionale Programmierung im deklarativen Bereich angesiedelt wird. Funktionale Programmierung zeichnet vor allem die Nutzung des Lambda-Kalküls aus. Dadurch wird programmatisch nicht die Frage nach dem \textit{Wie} gelöst, sondern ein Vorgang wird mit mathematischen Funktionen beschrieben\footnote{Verweis auf Lambda-Kalkül}. Wird eine funktionale Programmiersprache nun um den relevanten Faktor Zeit erweitert kann ein reaktives Verhalten beschrieben werden. Diese Art der Realisierung nennt man \textit{Functional Reactive Programming}\footnote{\cite{frp.haskell}}. Dieser Zeitfaktor zeigt sich im Funktionalen in der kontinuierlichen Wertänderung im Laufe der Zeit. Somit kann das FRP als Teilmenge des Paradigma der reaktiven Programmierung angesehen werden. Die Verwechslung der Begriffe entsteht wenn man sich zum Beispiel Java 8 anschaut. Mit Java 8 nahm die Klasse der Funktionen sowie die Lambda-Ausdrücke Einzug in die OO Programmiersprache\footnote{Noch Verweis suchen: Viele weitere bekannte Programmiersprache wie C\# z.B. unterstützen Lambdas ebenso} Java. Dadurch wird ein ähnliches Verhalten der Funktionalen Programmierung reproduziert. Somit kann innerhalb von Java reaktiv unter Zuhilfenahme von funktionalen Methodiken entwickelt werden. Der Unterschied findet sich also genau an der Stelle, dass funktionale Eigenschaften zwar in Java vorhanden sind, dadurch Java allerdings nicht als funktionale Programmiersprache verstanden werden kann, denn auch innerhalb der Objektorientierung kann auf dem imperativen Weg ein reaktives Verhalten entwickelt werden. Faktor Zeit wird im reaktiven Programmieren eher darin reflektiert, dass konkrete Werte im Laufe der Zeit gesendet werden. Reactive Programming kann somit als eine Abstraktion gesehen werden, die sich über die Vorhandenen Paradigmen erstreckt und je nach Situation und Anwendungsbereich auf andere Programmierstile zurück greift. 

\section{Wie wird Reactive Programming realisiert?}
Es wurde berichtet was allgemein unter einem reaktiven Verhalten verstanden wird. Ebenso wurde die Begrifflichkeiten und Zusammenhängen zwischen Reactive Programming, Reactive Systems und Functional Reactive Programming erläutert. Es stellt sich jedoch noch die Frage wieso aktuell die Reaktivität von Applikation stark gefordert wird und wie eine Umsetzung davon aussieht. Durch große Datenraten, Datenmengen und vielen vernetzten Geräte und Dienste die zur heutigen Zeit in Umlauf sind, entstehen viele Informationen die verarbeitet werden können beziehungsweise müssen. Durch die vielen Berechnungen und Verarbeitungsschritte die dafür nötig sind, spielt hier das Gesetz von Amdahl eine große Rolle\footnote{Vgl. \cite{Amdahl.}. Es handelt sich um einen Reprint in der IEEE SSCS News. Auf diesem von Amdahl verfassten Original resultiert das gleichnamige Gesetz.}. Dieses besagt, dass nie alle Teile eines Programms parallel ausgeführt werden können. Somit lohnt es sich, denn Ablauf in einen sequentiellen und einen parallelen Teil zu zerlegen. Die Blockade die somit noch bleibt, sind die Programmteile die sequentiell abgearbeitet werden müssen und nicht weiter optmiert werden können. Reactive Programming versucht nun eine Lösung abzubilden die den Ablauf innerhalb des parallelen Teils vereinfacht und beschleunigt um eine möglichst geringe Latenz und große Flexibilität und Reaktionsfreudigkeit eines Programms widerzuspiegeln. Ein Ansatz diese Lösung zu realisieren ist die Verwendung von Datenströmen. Die Stream-Api wurde wie die Lambda-Funktionalität mit Java 8 eingeführt. Sich veränderte oder neue Daten werden als Ströme betrachtet, die unter Beobachtung stehen und Änderungen sowie Bearbeitung der Daten asynchron und parallel zu den anderen Funktionen einer Anwendung ausgeführt werden können. Damit dieses Verfahren der Datenverarbeitung funktioniert, sind einige Konzepte zu beachten.
\subsection{Datenströme- Streams}
Das Konzept der Streams stellt eine Abstraktion für Folgen von Bearbeitungsschritten auf Daten dar\footnote{Vgl. \cite{Inden.2015}, Seite 42.}. Streams erinnern an Collections sind jedoch nur einmal traversierbar und nehmen keine direkten Speicherung der Daten vor. Collections können auch als Datenströme respräsentiert werden. Nahe liegt die verbreitete Analogie der Fließbandverarbeitung. Man hat eine Menge von Objekten die nacheinander gewissen Operationen unterzogen werden. Diese wird einmalig durchgeführt und die Zwischenergebnisse bleiben nicht vorhanden. 
\subsection{Massenverarbeitung - Bulk Operations}
Diese Operationen gelten als funktional in sind seit Java 8 auf Collections sowie Streams anwendbar. Diese Operation müssen nicht separat implementiert werden und können direkt auf Collections oder Streams ausgeführt werden\footnote{Beispiel Bulk Operation}. Somit kann durch eine Operation zum Beispiel eine Veränderung an jedem Objekt einer Liste ausgeführt werden, oder eben auf jedem Objekt welches einen Datenstrom durchquert. Die Operation können verkettet werden. Zu beachtet ist, dass jede Operation auf einer Kopie des eigentlichen Objekts ausgeführt wird, also bleibt zum Beispiel die Liste unverändert wenn man solch eine Massenoperation auf die Elemente der List ausführt. Als Ergebnis wird eine modifizierte Kopie der ursprünglichen Liste geliefert. Auch bei einer Verkettung wird immer nur eine Kopie des Eingangsobjekts modifiziert und weiter gereicht. Dies gilt äquivalent auch für Streams. Erwähnung sollte noch die unterschiedliche Art von Operation finden. Es wird zwischen drei Arten von Operationen unterschieden: \textit{Erzeugung}, \textit{Berechnung} und \textit{Ergebnisermittlung}\footnote{Vgl.: \cite{Inden.2015}, Seite 42f.} die sich wie folgt abbilden lassen: 
\begin{displaymath}
	\underbrace{Quelle \Rightarrow STREAM}_{Erstellung} \Rightarrow \underbrace{OP_{1} \Rightarrow OP_{2} \Rightarrow ... \Rightarrow OP_{n}}_{Berechnung} \Rightarrow \underbrace{Ergebnis}_{Ergebnisermittlung}
\end{displaymath}
Bei der Erzeugung wird von der Änderung der Datenrepräsentation von einem Datentyp einer Collection oder eines Arrays in einen Stream gesprochen. Java bietet hierfür für jeweils Arrays oder Collections Methoden an. Resultieren erhält man einen Datenstrom. Eine Reihe von Berechnungen kann nun verketten stattfinden, zum Beispiel eine direkte Manipulation oder Filterung nach Kriterien. Sind die Berechnungen abgeschlossen wird das Ergebnis zum Beispiel auf der Konsole ausgegeben oder in einem Datentyp gespeichert.
\subsection{Überdruck - Back pressure}
Man nehme an, zwei Datenströme stehen in Verbindung zueinander. Die Bearbeitung der einzelnen Ströme finden asynchron und parallel statt, so wie es bei der reaktiven Programmierung beabsichtigt wird. Der eine Datenstrom führt nun eine kurze Überprüfung durch der zweite führt eine Berechnung durch. Nach der Berechnung soll eine Verknüpfung mit dem nächsten Objekt des ersten Streams stattfinden, jedoch ist die Überprüfung doppelt so schnell. Dadurch entsteht ein Rückstau innerhalb des ersten Datenstroms. Dieses theoretische Beispiel zeigt, dass es bei der Arbeit mit vielen asynchronen und parallelen Operationen als sehr wichtig gilt, jede Interaktion zwischen zweier solcher Programmelemente genau zu kalkulieren. Findet dies nicht statt, kann zum Beispiel ein hoher Ressourcenverbrauch oder ein Programmabsturz die Folge sein.
\section{Reaktive Datenströme - Reactive Streams}
Festhalten lässt sich somit, dass die Verarbeitung von asynchronen, parallelen Datenströmen die Reaktivität generiert. Nach dem anfangs erwähnten Beobachtermuster werden die Ströme zum Beobachteten und die Daten werden den Beobachtern publiziert. In der Java Welt wurde die Initiative der \textit{Reactive Streams}\footnote{\cite{reactivestreams}} geschaffen, um einen Standard für die Verarbeitung von asynchroner Datenstromverarbeitung mit nicht blockierendem Überdruck zu etablieren. Das zu bewältigenden Problem ist die unterschiedliche Implementierung der bereits existierenden reaktiven Frameworks. Somit soll eine Kompatibilität von reaktiven Komponenten untereinander gesichert werden, auch wenn besagte Komponenten auf unterschiedliche Frameworks basieren. Viele Entwicklerteams von reaktiven Frameworks haben sich mittlerweile dieser Initiative angeschlossen und die Schnittstellen soweit angepasst, dass diese Kompatibilität gewährleistet werden kann\footnote{\cite{rs.implementations}}. Einige der hier aufgeführten Frameworks werden in folgendem Abschnitt noch genauer beschrieben. Mit Java 9 wird in der sogenannten \textit{Flow API}\footnote{\cite{fl.apidoc}} eine Implementierung nach den \textit{Reactive Streams}-Kriterien geliefert. Ein Anwendungsbeispiel wird von der offiziellen Java-Community bereits zur Verfügung gestellt\footnote{\cite{flowex}}.  
\section{Überblick über bekannte Frameworks und ihre Eigenschaften}
Die Welt der Softwareentwicklung bietet viele unterschiedliche Programmiersprachen für unterschiedliche Anwendungsfelder. Da es den Umfang dieser Arbeit überschreiten würde sich mit allen vorhandenen Frameworks zu den jeweiligen Sprachen zu befassen, wird auch in diesem Abschnitt hauptsächlich die Vielfalt innerhalb des Java Universums behandelt. Insbesondere die Reactor Bibliothek, das Akka Toolkit und die ReactiveX API, speziell RxJava.

\subsection{ReactiveX}
ReactiveX ist ein Open Source Projekt und vereint reaktive Bibliotheken für viele Sprachen und Frameworks unter einem Dach. Die Bibliotheken halten sich an den gleichen Aufbau und Benennung um eine gewisse Konsistenz zu erschaffen. Die erste dieser Bibliotheken wurde von Eric Meijer\footnote{Erik Meijer linken als initiator von rx} bei Microsoft entwickelt und nennt sich Rx.NET, als Erweiterung zum .NET Framework von Microsoft. Das Kürzel Rx steht für Reactive Extentions, also reaktive Erweiterung. Folgend wurde von Ben Christensen als Entwickler bei Netflix die Erweiterung für Java geschrieben und öffentlich gemacht. Es folgten viele weitere Implementierungen für zum Beispiel Ruby, Python oder JavaScript. Vorteil von diesen Erweiterung ist die Unabhängigkeit. Somit ist die Bibliothek sehr klein bringt jedoch die nötigen Eigenschaften mit, um asynchrone und nicht blockierende Anwendungen zu entwickeln. ReaktiveX sagt über sich, dass die besten Ideen des Beobachtermuster, des Iteratormusters sowie der funktionalen Programmierung hinter ihrer Art der Implementierung steckt. Die Schon in Java vorhandenen Klassen wurden überlagert und für ein reaktives Verhalten gerüstet. Aktuell wird RxJava als Version 1 und Version 2 entwickelt. In Version 2 wurden Änderungen vorgenommen um den Vorgaben der Reactive Streams Initiative zu genügen. Da es sich nicht nur um eine Erweiterung sondern um eine Neuentwicklung von Version 1 handelt, sind im Moment beide Versionen im Entwicklungsstatus und laufen parallel. RxJava2 wird in dieser Arbeit als Referenzbibliothek verwendet, daher folgt eine genau Beschreibung in einem weiteren Kapitel. Somit wird auf ein Beispiel in diesem Abschnitt verzichtet.
\subsection{Akka}
Akka bezeichnet sich selbst als Toolkit und nicht als Framework. Es kann wie jede beliebige Bibliothek in ein Java Projekt eingebunden werden. Jedoch ist diese Werkzeugkiste etwas umfangreicher als die Erweiterungen von ReactiveX. Spezielle das von Akka eingeführte Actor Modell spielt hier eine Rolle. \footnote{Beschreibung actor Modell, am besten mit Code beispiel}. Akka versucht mit seinem Vorgehen die Prinzipien des Reaktiven Manifest und auch der Reactive Stream Initiative umzusetzen.
\subsection{Reactor}
Reactor ist der ReactiveX Erweiterung sehr ähnlich. Die API ist bis auf ein paar Gemeinsamkeiten anders benannt, jedoch ist die Funktionalität fast deckungsgleich. Dies kommt daher, dass die Codebasen von beiden Projekten praktisch identisch sind\footnote{\cite{Karnok.2016}. Dávid Karnok, Projektleiter RxJava2 und Unterstützer von Reactor.} Beide Projekte arbeiten stark zusammen und beide haben schon von den jeweils anderen Implementierungen übernommen. Reactor existiert jedoch nur in der Java Welt und wird in ersten Sinne von Pivotal entwickelt. Dadurch ergibt sich auch die Nutzung in der neuesten Version des Webentwicklungs-Frameworks Spring 5. Die Reactive Bibliothek wird ab Version 5 direkt mit Spring ausgeliefert und soll eine reaktive Reaktion für REST-API's ermöglichen und vereinfachen. 
\subsubsection{Framework für JavaFX - RxJavaFX}
Einführung und Eigenschaften erläutern
\section{Testen von reaktivem Code mit dem JUnit Framework}
Noch nichts genaues. Muss noch geschaut werden wie die Funktionalität von JUnit RP abdeckt.
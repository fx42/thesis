\chapter{Was ist Reactive Programming}\label{was_ist_reactive_programming}
Ist mein neu in der Domäne von reaktiver Entwicklung stellt man schnell fest, dass allerhand mögliche Definitionen und Beschreibungen findet was Reactive Programming denn zu sein scheint. Bevor jedoch hier eine Definition erläutert wird, muss zwischen unterschiedlichen Begrifflichkeiten differenziert werden: \textit{Reactive Systems, Functional Reactive Programming} und natürlich \textit{Reactive Programming}. Vorab wird jedoch ergründet worum es sich grundlegend handelt und wieso es zur heutigen Zeit von Relevanz ist über die möglichen Verwendung von \textit{reactive} zu sprechen.
\section{Was bedeutet \textit{"reactive"} im Kontext der Softwareentwicklung}
Wie die Wortherkunft verlauten lässt, wird etwas als reaktiv bezeichnet, wenn eine Reaktion durch eine vorangegangene Aktion ausgelöst wird. Bei diesen Aktionen handelt es sich meist um Veränderungen an verwendeten Daten und stattfindende Ereignisse(\textit{Events}). Eine gutes Beispiel zur Veranschaulichung ist die Benutzeroberfläche(\textit{GUI}). Ein Benutzer bestätigt eine vorgenommene Eingabe durch das klicken eines Button innerhalb der GUI. Dieses Event sorgt dafür, dass die Applikation einen vorgegebenen Vorgang ausführt. Dieses Vorgehen sorgt in der klassischen Programmierweise mit sequentiellem Ablauf sowie dem imperativen Ansatz grundsätzlich für ein stetig wachsendes Maß an Komplexität. Durch die unterschiedlichen Events die innerhalb der GUI auftreten können(Mausklick, Tastendruck, usw.) ist ein klassischer imperativer sowie sequentieller Ablauf den Programmcodes nicht realistisch, da kein Entwickler weiß, in welcher Reihenfolge und zu welchem Zeitpunkt ein beziehungsweise welches Event ausgelöst wird. Somit spielt hier die \textit{Inversion of Control}\footnote{Vgl. \cite{MartinFowler.2005}, https://martinfowler.com/bliki/InversionOfControl.html.}, also das Umkehren der Kontrolle, eine große Rolle. Diese besagt, dass nicht der geschrieben Code den Ablauf beschreibt, sondern die Kontrolle bei dem Framework\footnote{In diesem Fall ein Framework für das Realisieren einer GUI. Vgl. \cite{wiki.guilist}.}, welches für die Interaktion zuständig ist, liegt, und dieses entscheidet wiederum wie und wann auf ein Event reagiert wird. Im Code spiegelt sich das dadurch wider, das mögliche Reaktionen, meist als Methoden oder Funktionen realisiert, an die mögliche eintreffenden Ereignisse gebunden werden. Dies geschieht über so genannte Event-Handler beziehungsweise Event-Listener oder über die Verwendung von Callbacks\footnote{TODO Beispiel Event-Handler -> ActionEvent, Click on Button; Quellen angeben und Beschreibung zu Beiden Codebeispielen}. Ein bewährtes und klassisches Vorgehen bei Anwendungsanforderungen dieser Art ist das schon 1994 von Erich Gamma und seinen Mitstreitern beschriebenes Entwurfsmuster\footnote{\cite{Gamma.2011}: Dieses Buch beschreibt viele noch heute verwendete Entwurfsmuster. Die Autoren sind in die Geschichte als die Gang Of Four (\textit{GoF}) eingegangen.}, dem \textit{Observer-Pattern}\footnote{Hier Beispiel vom OP sowie Übersetzung Beobachtermuster; Observer Pattern und Erklärung}. Man betrachtet hier grundlegend zwei Ansätze: \textit{push}  und \textit{pull}. \footnote{Hier gute Beispiele für push und pull Variante}. Auch hier lässt sich wieder die GUI als guten Beispiel heran ziehen. Man betrachtet eine Oberfläche welche die Temperatur im Raum anzeigt. Die Temperatur wird als Zahl in Grad Celsius sowie graphisch in einem Balken dargestellt. Obwohl beide Elemente auf die selben Daten zugreifen, stehen programmatisch die Objekte in keine Zusammenhang. Um nun das Beobachtermuster zu implementieren, muss der sich ändernde Wert der zum Beispiel von einem Temperatursensor gemessen wird regelmäßig aktualisiert werden. Das Objekt, welches den Temperaturwert inne hält wird somit als beobachtbar deklariert, die beiden Objekte, die Ausgabe per Zahlenwert und der graphische Balken, werden bei diesem Objekt als Beobachter registriert. Wenn man den push-Ansatz verfolgt, wird jedem Beobachter benachrichtigt und das Objekt mit den geänderten Daten steht dem Beobachter zur Verfügung. Verfolgt man den pull-Ansatz, werden die Beobachter nur kurz darüber informiert das sich Werte innerhalb des zu beobachtenden Objekts geändert haben, müssen jedoch aktiv anfragen um die geänderten Werte zu erhalten. Je nach Vorgehen ergeben sich Vor- und Nachteile. Der push-Ansatz steht eher für lose Kopplung, da der Beobachter keine Details zu dem zu beobachteten Objekt braucht. Jedoch sinkt dadurch die Flexibilität, da Beobachterschnittstellen exakter beschrieben werden müssen damit der Beobachtete weiß welche Information weiter gereicht werden sollen. Die Kopplung im Vergleich zum pull-Ansatz ist nicht wirklich lose, da jeder Beobachter wissen muss, welche Daten das observierte Objekt repräsentiert und wie auf diese Daten zugegriffen werden kann. Jedoch findet sich hier die Flexibilität wieder, da jeder Beobachter wenn er Information braucht, exakt diese Daten abrufen kann und sich nicht auf die korrekte Datenverteilung des Beobachteten verlassen muss. \\ Nach diesem Abschnitt sollte soweit klar sein, wie man ein reaktives Verhalten mit den schon bekannten Bordmitteln realisiert.
\subsection{Differenzierung zwischen Reactive Proramming und Reactive Systems}
Das zuvor angesprochene Verhalten bezieht sich nun auf ein Beispiel. Wie jedoch wirkt es sich aus, wenn eine komplette Anwendung unter Verwendung dieses Stils entwickelt wird? Wie verhält es sich weiter wenn mehrere Teile reaktiv funktionieren und kommunizieren sollen? Eine gute Richtlinie um Anwendungen reaktiv zu gestalten bietet das Reactive Manifesto\footnote{\cite{Boner.} -> ebenso Bild von Manifest einfügen. Deutsches Manifest in Quellen verlinken}. Laut Jonas Bonér und den vielen Unterstützern sind vier Bestandteile essentiell damit eine Anwendung die Anforderung erfüllt um sich reaktiv zu verhalten. Die Ansicht des Manifest stützt sich auf einen Architektur- beziehungsweise Designstil und soll als Grundlage zur Entwicklung Reaktiver Systeme dienen. Die folgenden Erklärungen sind dem Manifest entnommen und sollen einen Verständnis zu den vier Eigenschaften bieten. Wie in diesem beschrieben sind Reaktive Systeme:
\begin{itemize}
	\item \textbf{Antwortbereit (engl. responsive):}\\ Ein System muss immer zeitgerecht antworten. Die Antwortbereitschaft ist die Grundlage für die Benutzbarkeit besagten Systems. Ebenso wird um eine Fehlerbehandlung durchführen zu können eine geregelte Antwortbereitschaft vorausgesetzt.
	\item \textbf{Widerstandsfähig (engl. resilient):}\\ Ein System muss auch bei Ausfällen die Antwortbereitschaft aufrecht erhalten. Die wird durch Replikation der Funktionalität, der Isolation von Komponenten sowie dem Delegieren von Verantwortung erzielt. 
	\item \textbf{Elastisch (engl. elastic):}\\ Das System muss bei sich ändernden Lasten die Funktionalität und Antwortbereitschaft aufrecht erhalten. Ressourcen müssen den auftretenden Lasten, ob steigend oder sinken, angepasst werden können.Ebenso müssen Engpässe innerhalb des Systems unterbunden werden um die Elastizität zu bewahren.
	\item \textbf{Nachrichtenorientiert (engl. message driven):}\\ Ein loses System soll zur Kommunikation zwischen den Komponenten auf asynchrone, ortsunabhängige Nachrichtenübermittlung zurück greifen. Somit ist nicht relevant auf welchen Rechner die einzelnen Komponenten ausgeführt werden, wodurch wiederum eine gute Skalierbarkeit entsteht.
\end{itemize}
Das Manifest erwähnt jedoch in keinster Weise den Zusammenhang von Systemen zum reaktiven Programmieren. Auch aus diesem Grund hat Jonas Bonér einen weiteren Artikel verfasst, der auch dieses beschreibt. 
\section{Reactive Programming vs. Functional Reactive Programming}
FRP findet nun mal in Funktionalen Programmiersprachen statt. Java is jedoch OO und mit Java 8 und dem Rx Frameworks werden funktionale Eigenschaften in der OO Sprache eingebracht. Unterschiede müssen noch genau belegt\footnote{\cite{Lohmuller.2016}} werden.
Der grundlegende Gedanke reaktiver Systeme wurde schon im Jahre 1985 in einem Paper von D. Harel und A. Pnueli beschrieben\footnote{\cite{Harel1985}}. 
\section{Reactive Programming - Ein neues Programmierparadigma?}
Wie gliedert man einen Programmierstil ein? \footnote{\cite{Bainomugisha.2013}}
\subsection{Was versteht man unter Programmierparadigmen}
 Erklärung was sind Paradigmen und wieso werden sie definiert.
\subsection{Vergleich: Reactive Programming und Objekt orientierte Programmierung}
Eventuell bessere mit Funktionaler Programmierung zu vergleichen. Muss noch genauer betrachtet werden. Soll die Unterschiede zu den gängigen, bekannten Methoden aufzeigen.
\section{Überblick über bekannte Frameworks und ihre Eigenschaften}
Überblick quer über die gängigen Programmiersprachen. 
\subsection{Reactivex.io}
Kurze Erläuterung zu der Entstehung von Reactive Extensions
\subsection{Allgemeine Übersicht}
Rx Frameworks zu den jeweiligen Sprachen. Frameworks wie z.B. Akka\footnote{\cite{Karnok.2016}}. 
\subsection{Übersicht spezielle für die Entwicklung mit Java}
RxJava. Reactive Streams Konvention. Java 9 Api Änderung bzgl. Reactive Streams.
\subsubsection{Framework für JavaFX - RxJavaFX}
Einführung und Eigenschaften erläutern
\section{Testen von reaktivem Code mit dem JUnit Framework}
Noch nichts genaues. Muss noch geschaut werden wie die Funktionalität von JUnit RP abdeckt.
\chapter{Beispiel: Implementierung eines Systemmonitors}\label{beispiel}
In diesem Kapitel soll nun eine kleine Anwendung beschrieben werden die einige der zuvor geschilderten Methoden implementiert. Augenmerk liegt hier auf der Erstellung von Observables und die weitere Verwendung dieser. Als Beispiel soll ein Systemmonitor dienen. Hierfür werden die aktuelle Auslastung der Kerne, die ausgeführten Prozesse sortiert nach der CPU-Auslastung sowie der aktuell genutzte RAM ausgelesen und auf einer Oberfläche dargestellt. Die Implementierung wurde mit Java 8u121 und RxJava 2.0.8 realisiert. Zusätzlich kamen noch die Bibliotheken RxJavaFX 2.0.2, JavaFX 8 sowie Oshi 3.4.0 zum Einsatz \cite{rxajavafx}, \cite{oshi}.  
\section{Klassenbeschreibung SystemProvider}
Um sicherzustellen das die geforderten Daten des Systemmonitors verfügbar sind, wurde das ISystemProvider-Interface implementiert. 
\lstinputlisting[linerange={7-19}, caption={ISystemProvider-Interface}, label=lst:interface]{../SystemMonitor/src/main/java/provider/ISystemProvider.java} 
Listing \ref{lst:interface} zeigt die zu implementierenden Methoden. Die festen Größen wie die Anzahl der Kerne und der verfügbare RAM werden als einfache Datentypen zur Verfügung gestellt. Die variablen Werte, also CPU-Auslastung, Prozesse und genutzter Speicher werden durch Observables repräsentiert. Die Implementierung dieser Methoden wurden in der Klasse SystemProvider vorgenommen. Das Oshi-Framework bietet eine Schnittstelle um auf Systeminformationen außerhalb der JVM zuzugreifen. Als Einstiegspunkt dient immer ein Objekt der SystemInfo-Klasse. Dieses bietet die weiteren Informationen über das Betriebssystem oder die verwendete Hardware der Maschine. Der SystemProvider wurde als Singleton implementiert, wodurch auch nur eine Instanz der SystemInfo-Klasse verwendet wird um die spezifischen Systeminformationen abzurufen. Interessant ist nun die Implementierung von den Methoden \textit{fetchCpuValues}, \textit{getAvailableMemory} und \textit{getProcesses}. 
\subsection{List< Observable< Double > > fetchCpuValues()}
\lstinputlisting[linerange={45-56}, caption={SystemProvider - Implementierung der fetchCpuValues()-Methode}, label=lst:fetch]{../SystemMonitor/src/main/java/provider/SystemProvider.java} 
Die Implementierung der \textit{fetchCpuValues()}-Methode ist in Listing \ref{lst:fetch} zu sehen. Die sich ändernden Werte liegen in Datentyp Double vor und sind die Stelle die beobachtet werden soll. Somit wird für jeden Kern ein separates Interval-Observable gestartet. Die Taktung des Intervalls liegt bei einer Sekunde. Der vom Intervall generierte Wert wird vernachlässigt. Jedoch wird der Takt genutzt um eine Abfrage über die aktuelle Auslastung eines Kerns durchzuführen. Bei einem 4-Kern Prozessor wird also eine Liste mit vier Observables von der Methode zurück geliefert. Da es sich um Cold-Oservables handelt werden zu diesem Zeitpunkt noch keine Werte ausgeben. Noch zu erwähnen ist, das ein Scheduler genutzt wird um diesen Vorgang durchzuführen. Somit wird nicht der Thread der möglichen Subscriber verwendet, was ein Blockieren verhindern soll. 
\subsection{Observable< Long > getAvailableMemory()}
\lstinputlisting[linerange={64-68}, caption={SystemProvider - Implementierung der getAvailableMemory()-Methode}, label=lst:memorymethod]{../SystemMonitor/src/main/java/provider/SystemProvider.java} 
In Listing \ref{lst:memorymethod} sieht man die Implementierung der Methode zum Erhalt des aktuell verfügbaren Speichers. Die Abfrage des Werts wird wieder mit einem Intervall durchgeführt und die Werte werden durch ein Observable repräsentiert. Auch hier wird wieder der Computation-Scheduler als Threadpool verwendet.
\subsection{Observable< List< String > > getProcesses()}
\lstinputlisting[linerange={76-97}, caption={SystemProvider - Implementierung der getProcesses()-Methode}, label=lst:processmethod]{../SystemMonitor/src/main/java/provider/SystemProvider.java} 
Die in Listing \ref{lst:processmethod} gezeigte Methode liefert ebenfalls ein Observable-Ojekt zurück. Unterschied ist hier jedoch, dass nicht nur ein Wert beobachtet wird, sondern die komplette Liste der Prozesse. Zusätzlich zum getakteten Aufruf der getProcesses()-Methode der SystemInfo-Klasse wird hier die Datenrepräsentation der Objekte geändert. Durch die Funktion \textit{func} wird aus den einzelnen Prozessen eine Liste bestehend aus der PID(ProcessID) sowie dem Prozessnamen. Die Liste repräsentiert 16 Prozesse sortiert nach der CPU-Auslastung.
\section{Klassenbeschreibung MainApplication}
Der bisherige Teil der Implementierung hat nur die Datenbeschaffung erledigt. Es fehlt die Repräsentation dieser Daten auf der Oberfläche. Hierzu dient die Klasse \textit{MainApplication}. Durch das JavaFX-Framework kann eine einfache Oberfläche schnell implementiert werden. Durch das Erweitern der Klasse mit der abstrakten Klasse \textit{Application} des JavaFX-Frameworks muss die Methode \textit{start()} implementiert werden. Es wird die Basis für die graphische Darstellung in Form der ersten \textit{Stage} gelegt. Auf dieser Stage werden alle Elemente die dargestellt werden sollen durch ein Wurzelobjekt zusammengeführt. 
\lstinputlisting[linerange={37-51}, caption={MainApplication - Implementierung der start()-Methode}, label=lst:mainstart]{../SystemMonitor/src/main/java/application/MainApplication.java} 
Wie dies genau geschieht wird in Listing \ref{lst:mainstart} beschrieben. Mit der BorderPane wird ein Wurzelelement der Oberfläche geschaffen. Darauf werden horizontal angeordnet die eigentlichen Knoten(Nodes) festgelegt. Die Anordnung wird durch die verwendete \textit{HBox} übernommen. Die statischen Methoden \textit{createBarChart()}, \textit{createProcessList()} und \textit{createPieChart()} sind die Methoden auf welche das eigentliche Augenmerk gerichtet wird, denn in diesen Methoden werden die Observables der Systeminformationen verwendet. 
\subsection{Node createBarChart()}

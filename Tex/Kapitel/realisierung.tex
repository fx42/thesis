\chapter{Bausteine von Reactive Programming}\label{realisierung} 
Durch große Datenraten, Datenmengen und vielen vernetzten Geräte und Dienste die zur heutigen Zeit in Umlauf sind, entstehen viele Informationen die verarbeitet werden können beziehungsweise müssen. Durch die vielen Berechnungen und Verarbeitungsschritte die dafür nötig sind, spielt hier das Gesetz von Amdahl eine große Rolle \cite{Amdahl.}. Dieses besagt, dass nie alle Teile eines Programms parallel ausgeführt werden können. Deshalb zerlegt man das Programm in eine sequentiellen und einen parallelen Teil. Reactive Programming versucht nun eine Lösung abzubilden, welche die Auslastung der Rechenressourcen optimiert und die Anzahl der Stellen welche serialisiert ablaufen zu verringern \cite{Boner.}. Ein Ansatz diese Lösung zu realisieren ist die Verwendung von besagten Reactive Streams. Neu auftretende Daten werden als Ströme betrachtet, die unter Beobachtung stehen und Änderungen sowie Bearbeitung der Daten asynchron und parallel zu den anderen Funktionen einer Anwendung ausgeführt werden können. Damit dieses Verfahren der Datenverarbeitung funktioniert, sind einige Konzepte zu beachten.
\section{Observer Pattern}
Ein bewährtes und klassisches Vorgehen bei Anwendungsanforderungen dieser Art ist das schon 1994 von Erich Gamma beschriebene Entwurfsmuster, dem \textit{Observer-Pattern} \cite{Gamma.2011}. Auch hier lässt sich wieder die GUI als guten Beispiel heran ziehen. Man betrachtet eine Oberfläche welche die Temperatur im Raum anzeigt. Um nun das Beobachtermuster zu implementieren, muss der sich ändernde Wert, der zum Beispiel von einem Temperatursensor gemessen wird, beobachtet werden. Dieser Sensor repräsentiert in Abbildung \ref{pic:observerpattern} eine Implementierung des Subject. Man nehme an auf der GUI soll der Temperaturwert als Balkendiagramm(BarChartForTemp), also als Art Thermometer dargestellt werden. Ebenso soll die aktuelle Temperatur in Schrift(LabelForTemp) auf der GUI erscheinen. Die beiden Objekte implementieren beiden das Observer-Interface wie in Abbildung \ref{pic:observerpattern} gezeigt. Dies heißt wiederum, dass diese beiden Observer die \textit{register()}-Methode des Subjects aufrufen und somit in die Observer-Liste dieses Subjects, also dem Sensor, aufgenommen werden. Ändert sich nun zum Beispiel die Temperatur wird die \textit{notifyObservers()}-Methode aufgerufen, was heißt, dass über die Liste der Observer iteriert wird und die \textit{update()}-Methode jedes Observers aufgerufen wird.
\begin{figure}
	\centering
	\includegraphics[width=0.85\textwidth]{Abb/observerpattern_self}
	\caption{Schematischer Aufbau eines Observer Patterns.}
	\label{pic:observerpattern}
\end{figure}
Diese Methoden können nach dem \textit{Push} oder \textit{Pull} Verfahren implementiert werden. Bei Verwendung des Push-Modells wird dem Observer der Wert des geänderten Parameters direkt mitgeteilt. Das Pull-Modell verfolgt den Ansatz, dass der Observer eine Information erhält, dass sich Werte geändert haben, muss jedoch über die Getter-Methoden die für ihn relevanten Wert aktiv nachfragen. Je nach Vorgehen ergeben sich Vor- und Nachteile. Der Push-Ansatz steht eher für lose Kopplung, da der Observer keine Details des Subject wissen muss. Jedoch sinkt dadurch die Flexibilität, da Observer Interfaces exakter beschrieben werden müssen, damit das Subject weiß, welche Information weiter gereicht werden sollen. Die Kopplung im Vergleich zum Pull-Ansatz ist nicht wirklich lose, da jeder Beobachter wissen muss, welche Daten das observierte Objekt repräsentiert und wie auf diese Daten zugegriffen werden kann. Jedoch findet sich hier die Flexibilität wieder, da jeder Beobachter wenn er Information braucht, exakt diese Daten abrufen kann und sich nicht auf die korrekte Datenverteilung des Subjects verlassen muss.
\section{Back Pressure}
Der weitere wichtiger Aspekt der Reactive Streams ist ein nicht blockierender Back Pressure. Man betrachtet hier den Push-Ansatz. Ein Producer generiert Daten, die ein Consumer verarbeitet. Es kann nun passieren das mehr Daten produziert werden als konsumiert werden können. Wird darauf nicht reagiert, kann es zu starken Ressourcenproblemen oder zu einem Programmabsturz durch einen \textit{OutOfMemoryError} kommen. Um dies zu verhindern, benötigt man eine Möglichkeit, die Anzahl der zu verarbeitenden Objekte zu regulieren. Ein sogenannter \textit{Feedback Channel} steht dafür zur Verfügung. Über diesen kann ein Consumer seinem Producer mitteilen, mit wie vielen Objekten er maximal umgehen kann. Dadurch ergibt sich die Möglichkeit auf Seiten des Producers seine Datenbeschaffung und Datenweitergabe zu regulieren, sodass der Producer zu jeder Zeit verwendbar bleibt und nicht blockiert. Dies geschieht zum Beispiel über einen zusätzlichen Puffer an Ausgang des Producers, wodurch die direkte Datenweitergabe verzögert werden kann. Dies besteht jedoch nur, wenn des dem Producer auch möglich ist, seine Geschwindigkeit zu steuern. Zu beachten ist, dass grundsätzlich jeder Consumer über einen Eingangspuffer verfügt, in welchem die geforderten Objekte zwischen lagern. Wird der Back Pressure nicht richtig behandelt oder die Puffer fehlerhaft konfiguriert, kann es zu eine \textit{MissingBackPressureException} kommen.
\section{Reactive Streams}
 Nach dem anfangs erwähnten Observer Pattern werden die Streams observiert und die Daten werden den Observern publiziert. Verfügen diese Observable Streams nun über die Funktionalität des Back Pressures ist eine nicht blockierende asynchrone Bearbeitung möglich. Nach diesen Voraussetzungen wurde in der Welt der JVM die Initiative der \textit{Reactive Streams} geschaffen, um einen Standard für diese Art von Verarbeitung zu etablieren \cite{rsmain}. Das zusätzlich zu bewältigenden Problem ist die unterschiedliche Implementierung der bereits existierenden reaktiven Frameworks. Durch die Standardisierung soll eine Kompatibilität von reaktiven Komponenten untereinander gesichert werden, auch wenn besagte Komponenten auf unterschiedliche Frameworks basieren. Viele Entwicklerteams von reaktiven Frameworks haben sich mittlerweile dieser Initiative angeschlossen und die Schnittstellen soweit angepasst, dass diese Kompatibilität gewährleistet werden kann \cite{rslsting}. Mit Java 9 wird in der sogenannten \textit{Flow API} eine Implementierung nach den \textit{Reactive Streams}-Kriterien geliefert \cite{flowdoc}. Ein Anwendungsbeispiel wird von der offiziellen Java-Community bereits zur Verfügung gestellt \cite{flowexmpl}. 